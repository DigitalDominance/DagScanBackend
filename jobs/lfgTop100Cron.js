const cron = require('node-cron');
const mongoose = require('mongoose');
const LFGToken = require('../models/LFGToken');
const LFGTokenPrice = require('../models/LFGTokenPrice');
const LFG_BASE = 'https://api.dev-lfg.kaspa.com/tokens/search';
const DEFAULT_SORT = 'Market Cap (High to Low)';
const doFetch = async (url) => { if (global.fetch) return fetch(url); const { default: fetchPoly } = await import('node-fetch'); return fetchPoly(url); };
const minuteBucket = (d = new Date()) => new Date(Math.floor(d.getTime() / 60000) * 60000);
async function ensureIndexes(){ try{ await LFGTokenPrice.syncIndexes(); }catch(e){} try{ const coll = mongoose.connection.db.collection('cron_locks'); await coll.createIndex({ expiresAt:1 }, { expireAfterSeconds:0 }); }catch(e){} }
async function acquireMinuteLock(lockName){ const coll = mongoose.connection.db.collection('cron_locks'); const key = lockName+':'+minuteBucket(new Date()).toISOString(); try{ await coll.insertOne({_id:key,createdAt:new Date(),expiresAt:new Date(Date.now()+10*60*1000)}); return true; }catch(e){ return false; } }
async function fetchTopTokens(pages=6, cap=100){ const out=[]; for(let p=1;p<=pages;p++){ const url = new URL(LFG_BASE); url.searchParams.set('sortBy',DEFAULT_SORT); url.searchParams.set('view','grid'); url.searchParams.set('page',String(p)); try{ const r = await doFetch(url.toString()); if(!r.ok) break; const payload = await r.json(); const items = Array.isArray(payload?.result) ? payload.result : []; out.push(...items); if(!payload?.hasMore) break; } catch(e){ break; } } const seen=new Set(), unique=[]; for(const it of out){ const addr=String(it.tokenAddress||'').toLowerCase(); if(!addr||seen.has(addr)) continue; seen.add(addr); unique.push(it); if(unique.length>=cap) break; } return unique; }
async function snapshotTop(tokens){ if(!tokens.length) return; const snapAt = minuteBucket(new Date()); const tokenOps=tokens.map(it=>({updateOne:{filter:{tokenAddress:String(it.tokenAddress||'').toLowerCase()},update:{$set:{...it,updatedAtRemote:it.updatedAt?new Date(it.updatedAt):undefined,lastSyncedAt:new Date()}},upsert:true}})); const priceOps=tokens.map(it=>{ const addr=String(it.tokenAddress||'').toLowerCase(); const vol=it.volume||{}; const chg=it.priceChange||{}; return {updateOne:{filter:{tokenAddress:addr,snappedAt:snapAt},update:{$set:{price:Number(it.price||0),marketCap:Number(it.marketCap||0),volume1h:Number(vol['1h']||0),volume4h:Number(vol['4h']||0),volume12h:Number(vol['12h']||0),volume1d:Number(vol['1d']||0),volume3d:Number(vol['3d']||0),volume7d:Number(vol['7d']||0),change1h:Number(chg['1h']||0),change4h:Number(chg['4h']||0),change12h:Number(chg['12h']||0),change1d:Number(chg['1d']||0),change3d:Number(chg['3d']||0),change7d:Number(chg['7d']||0)}},upsert:true}}}); if(tokenOps.length) await LFGToken.bulkWrite(tokenOps,{ordered:false}); if(priceOps.length) await LFGTokenPrice.bulkWrite(priceOps,{ordered:false}); }
let running=false; async function tick(){ if(running) return; running=true; try{ await ensureIndexes(); const lockOk = await acquireMinuteLock('LFG_TOP100'); if(!lockOk) return; const list = await fetchTopTokens(6,100); await snapshotTop(list); }catch(e){ } finally{ running=false; } }
function startLFGTop100Cron(){ const enabled = (process.env.LFG_CRON_ENABLED||'true').toLowerCase()!=='false'; if(!enabled){ return; } cron.schedule('* * * * *', tick); }
module.exports = { startLFGTop100Cron };
